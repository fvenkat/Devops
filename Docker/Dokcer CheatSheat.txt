#List Images [Docker image ls]
============
$ docker images
$ docker image ls							# All
$ docker image ls -a                        # All
$ docker image ls <imageName>:<version>
$ docker image ls -q                        # Quiet [display only image ID]
$ docker image ls --no-trunc
$ docker image ls --digests

	Filter supports Dangling | Label | Before | Since | Reference

$ docker image ls --filter "dangling=true"        # Display untagged images			[--filter or -f]
$ docker image ls --filter "label=com.example.version"
$ docker image ls --filter "before=image1"
$ docker image ls --filter "since=image3"
$ docker image ls --filter=reference="jenkins/*:latest*" --filter=reference="hell*:lat*"


Remove Images [Docker image rm]
==============
$ docker image rm <imageName>
$ docker image rm <imageName> -f   (force)
$ docker image rm $(docker image ls -aq)


Image Prune [Docker image prune]
===============
$ docker image prune                # Remove all dangling images  [Untagged images]
$ docker image prune -a             # Remove all unused images, not just dangling ones [Remove all images without at least one container associated to them]
$ docker image prune -f             # force


Show the history of an image and its layer [ Docker Image history]
====================
$ docker image history [OPTIONS] IMAGE
$ docker image history <imageName>
    --human , -H    true	Print sizes and dates in human readable format
    --no-trunc              Don't truncate output
    --quiet , -q            Only show image IDs
    --format                Pretty-print images using a Go template
            .ID  | .CreatedSince | .CreatedAt | .Size | .Comment

$ docker image history docker:scm
$ docker image history --format "{{.ID}}: {{.CreatedSince}}" busybox


Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE [docker image tag]
==========================================================
    During build
        $ docker image build -t tagName:version .

    Tagging Existing image
    $ docker image tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]

Display detailed information on one or more images [Docker Image Inspect]
=========================================================

    $ docker image inspect [OPTIONS] NAME|ID [NAME|ID...]
        --format , -f       Format the output using the given Go template

    Example using grep
    Display Entire data ::                  $ docker image inspect nginx | grep Hostname
    Display Image ID::                      $ docker image inspect nginx --format='{{.ID}}'
    Display the os of the image [Linux]:    $ docker image inspect --format='{{.Os}}' nginx


    Image ID | RepoTags | RepoDigests | Parent
    Comment | Created Date | Architecture | Size OS | Container Associated
    Container Config:
            Hostname |DomainName| ENV| CMD| VOLUME
            WORKDIR| ENTRYPOINT| LABEL


Push an image or a repository to a registry
==========================================

    $ docker image push [OPTIONS] NAME[:TAG]

        --all-tags , -a             Push all tagged images in the repository
        --disable-content-trust     true	Skip image signing
        --quiet , -q                	Suppress verbose output


        $ docker login
        $ docker image tag firstimage YOUR_DOCKERHUB_NAME/firstimage
        $ docker image tag golang fvenkat/golang
        $ docker push fvenkat/golang

    $ docker image push registry-host:5000/myadmin/rhel-httpd:latest

Pull an image or a repository from a registry
=============================================

    $ docker image pull [OPTIONS] NAME[:TAG|@DIGEST]

        --all-tags , -a             Push all tagged images in the repository
        --disable-content-trust     true	Skip image signing
        --quiet , -q                	Suppress verbose output


    By default the Docker daemon will pull three layers of an image at a time.
    If you are on a low bandwidth connection this may cause timeout issues and you may want to lower
    this via the --max-concurrent-downloads daemon option. See the daemon documentation

    Pull an image by digest (immutable identifier)
    ----------------------------------------------
    In some cases you don’t want images to be updated to newer versions, but prefer to use a fixed version of an image.
    Docker enables you to pull an image by its digest. When pulling an image by digest, you specify exactly which version
    of an image to pull. Doing so, allows you to “pin” an image to that version, and guarantee that the image you’re
    using is always the same.

    To know the digest of an image, pull the image first. Let’s pull the latest ubuntu:14.04 image from Docker Hub:
    Docker prints the digest of the image after the pull has finished. Docker also prints the digest of an image when pushing to a registry.
    This may be useful if you want to pin to a version of the image you just pushed.

        $  docker image pull ubuntu@sha256:82becede498899ec668628e7cb0ad87b6e1c371cb8a1e597d83a47fac21d6af3

    Pull from a different registry
    ---------------------------------

        $ docker pull myregistry.local:5000/testing/test-image



Save one or more images to a tar archive[docker image save]
========================================================

    To share or back up our image, we use the docker save command

    $ docker image save [OPTIONS] IMAGE [IMAGE...]
            -o		Write to a file, instead of STDOUT


    Create a backup that can then be used with docker load.

            $ docker image save ImageName > ImageName.tar
            $ docker image save 15ca549393be > /tmp/phpmyadmin_image.tar
            $ docker image save busybox --output busybox.tar

    Save an image to a tar.gz file using gzip
        $ docker save myimage:latest | gzip > myimage_latest.tar.gz

    If you want to export all images at once, create one big tar file:
        $ docker image save $(docker images -q) -o /path/to/save/mydockersimages.tar

        IDS=$(docker images | awk '{if ($1 ~ /^(debian|centos)/) print $3}')
        $ docker save $IDS -o /path/to/save/somedockersimages.tar

Load an image from a tar archive or STDIN [docker load]
======================================================
         $ docker image load [OPTIONS]
                i	Read from tar archive file, instead of STDIN
                -q 	Suppress the load output

         $ docker load < busybox.tar.gz
         $ docker images
         $ docker image load --input fedora.tar


Export a container’s filesystem as a tar archive [docker export]
=========================================================

$ docker export [OPTIONS] CONTAINER
           --output , -o        	Write to a file, instead of STDOUT
            The docker export command does not export the contents of volumes associated with the container.

        $ docker export red_panda > latest.tar
        $ docker export --output="latest.tar" red_panda


Import the contents from a tarball to create a filesystem image
===============================================
    First export the container to tar file then use import command
    $ docker import calc-container.tar calcfs:latest
    $ docker image ls

Build an Image [Docker image build]
=============================
https://levelup.gitconnected.com/the-whole-docker-shebang-part-1-docker-build-470f0c265702

	--tag , -t						Name and optionally a tag in the 'name:tag' format
	--file , -f						Name of the Dockerfile (Default is 'PATH/Dockerfile')
	--build-arg						Set build-time variables
	--add-host  					Add a custom host-to-IP mapping (host:ip)
	--cache-from					Images to consider as cache sources
	--compress						Compress the build context using gzip
	--cpu-period					Limit the CPU CFS (Completely Fair Scheduler) period
	--cpu-quota						Limit the CPU CFS (Completely Fair Scheduler) quota
	--target						Set the target build stage to build
	--disable-content-trust			Skip image verification
	--force-rm						Always remove intermediate containers
	--iidfile						Write the image ID to the file
	--label							Set metadata for an image
	--memory , -m						Memory limit
	--network						Set the networking mode for the RUN instructions during build
	--no-cache							Do not use cache when building the image
	--output , -o					Output destination (format: type=local,dest=path)
	--pull								Always attempt to pull a newer version of the image
	--quiet , -q					Suppress the build output and print image ID on success
	--rm							true	Remove intermediate containers after a successful build
	--secret						Secret file to expose to the build (only if BuildKit enabled): id=mysecret,src=/local/secret
	--ssh							SSH agent socket or keys to expose to the build (only if BuildKit enabled) (format: default|<id>[=<socket>|<key>[,<key>]])


	Build with Path && Build with URL
	---------------------------------

	$ docker image build .
	$ docker image build github.com/creack/docker-firefox
						clone the GitHub repository and use the cloned repository as context. The Dockerfile at the root of the repository is used as Dockerfile
						A repository is first pulled into a temporary directory on your local host. After that succeeds, the directory is sent to the Docker daemon as the context.

	$ docker image build https://github.com/docker/rootfs.git#container:docker		 Use a directory called docker in the branch container


																		Build Syntax					Commit Used				Context
																		myrepo.git						refs/heads/master		/
																		myrepo.git#mytag				refs/tags/mytag			/
																		myrepo.git#mybranch				refs/heads/mybranch		/
																		myrepo.git#pull/42/head			refs/pull/42/head		/
																		myrepo.git#:myfolder			refs/heads/master		/myfolder
																		myrepo.git#master:myfolder		refs/heads/master		/myfolder
																		myrepo.git#mytag:myfolder		refs/tags/mytag			/myfolder
																		myrepo.git#mybranch:myfolder	refs/heads/mybranch		/myfolder

	$ docker image build -f ctx/Dockerfile http://server/ctx.tar.gz		Build with TAR FILE     -f ctx/Dockerfile parameter specifies a path inside ctx.tar.gz
	$ docker image build - < Dockerfile    							    Build with -
	$ docker image build - < context.tar.gz								Build with -

	Tag an Image && build it
	------------------------

	$ docker image build -t vieux/apache:2.0 .												repository name will be vieux/apache
	$ docker image build -t whenry/fedora-jboss:latest -t whenry/fedora-jboss:v2.1 .		Multiple tag for single image

	Specify a Dockerfile (-f)
	--------------------------

	$ docker image build -f Dockerfile.debug .			This will use a file called Dockerfile.debug for the build instructions instead of Dockerfile
	$ docker image build -f /home/me/myapp/dockerfiles/debug /home/me/myapp
	$ docker image build -f ../../../../dockerfiles/debug /home/me/myapp

				Above 2 use the contents of the debug file instead of looking for a Dockerfile and will use /home/me/myapp as the root of the build context.
				Note that debug is in the directory structure of the build context,


	Set Build Time varaibles (--build-arg)
	-----------------------------------------
	$ docker image build -t imageName:version -f dockerfile --build-arg HTTP_PROXY=http://10.20.30.2:1234 --build-arg FTP_PROXY=http://40.50.60.5:4567 .
						FTP_PROXY is defined in Dockerfile as ARG FTP_PROXY
						You may also use the --build-arg flag without a value, in which case the value from the local environment will be propagated into the Docker container being built:
						$ export HTTP_PROXY=http://10.20.30.2:1234
						$ docker build --build-arg HTTP_PROXY .


	Add entries to container hosts file (--add-host)
	------------------------------------------------
	$ docker image build --add-host=docker:10.180.0.1 .
			--add-host=host:ip
			You can add other hosts into a container’s /etc/hosts file by using one or more --add-host flags. This example adds a static address for a host named docker
			Remember, this host is only available at build time. To make a custom host-to-IP mapping available to a container, please use--add-hostoption with the docker run command.



	Specifying external cache sources  (--cache-from) ENABLE BUILDKIT
	------------------------------------------------------------------
	This option requires the BuildKit backend. By now, you’ve already noticed that when you rebuild an image from the same Dockerfile, without any changes, Docker will use the previous build’s cache to speed up your current build. Typically, Docker uses the local cache, but you can also decide to use a remote cache, to accelerate image builds on machines where you’re building a certain image for the first time.

	 The following example builds an image with inline-cache metadata and pushes it to a registry, then uses the image as a cache source on another machine:
		$ docker build -t myname/myapp --build-arg BUILDKIT_INLINE_CACHE=1 .
		$ docker push myname/myapp

	 After pushing the image, the image is used as cache source on another machine.
	 On Another Machine
	 $ docker build --cache-from myname/myapp .


	 --compress
	 ----------------
	 When you use this --compress build option, you are basically asking Docker to compress that context,  Docker compressed it before sending it to our build process. As a result, we’ve reduced our build time by more than 50%.

	 $ time docker build --compress .


	 --cpu-period, --cpu-quota
	 ---------------------------
	 These two options are used together, and they basically let you specify how much of the available CPU resources the build containers can use.If you want your Docker image build to only make use of 50% of that CPU, you should run your build as follows:

	 $ docker build --cpu-period=100000 --cpu-quota=50000 .


	 --disable-content-trust
	 ------------------------

	 Error: remote trust data does not exist for docker.io/ccordeiro/cache-from: notary.docker.io does not have trust data for docker.io/ccordeiro/cache-from
	 As you can see, Docker will complain because it doesn’t trust that base Docker image

	 $ DOCKER_CONTENT_TRUST=1 docker build --disable-content-trust .


	 --force-rm
	 --------------------
	 Whenever you build a Docker image, Docker will create Docker containers to execute the instructions from your Dockerfile.   A cool troubleshooting feature of Docker, is that if a build goes wrong, Docker will not destroy the container where the exception was raised. By using this --force-rm option, you’re telling Docker to delete those build containers, no matter what.

	 If it was successful, you’ll see that no containers are leftover from this build: However, if we introduce a runtime error into our Dockerfile: And you’ll find a container leftover from this build:

		$ docker ps -a
		CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS                        PORTS     NAMES
		3af17dec07b4   d4ff818577bc   "/bin/sh -c 'echox H…"   58 seconds ago   Exited (127) 58 seconds ago             affectionate_satoshi
		$ docker container prune  # just to clean this up

		$ docker build --force-rm .


	 --rm
	 ----------
		Remember the --force-rm option above? Well this is simlar, but it only applies to successfull builds. By default, after a successful build, all intermediate containers used for that build are removed. Meaning that you can no longer see them, even with docker ps -a .
		Because this is already the default Docker behavior, you don’t need to be explicit about this option…in fact, you don’t need to use it at all.



	 --iidfile
	 -------------
	 So, all Docker images have an ID, right? That’s the string you always get at the end of each build, as in “Successfully built <id>”. With this build option, you can ask Docker to save that ID into a file, for convenience.
		$ docker build --iidfile my-image-id .

		And then you’ll find a new file “my-image-id” within the same directory:

	 --label
	 ---------------

	 As the name says, this option lets you set labels for your Docker image. You can set these labels through the Dockerfile via the LABEL instruction, but alternatively, you can also set them at build time, via the CLI.

		$ docker build -t myimage --label my_build_label=bar --label x=1 .


	 --memory
	 ------------------

		Similarly to the --cpu* options mentioned above, this option lets you define a limit for the amount of memory your image build can take. Please note that this option is only valid if your Kernel supports it and the respective memory cgroup is enabled. Otherwise, the option will have no effect.

		Now let’s say you don’t want your build to take more than ~10MB of memory. Then we do:

		$ docker build --memory 10000000 .

	--network
	-----------------

	Pretty much like when you’re running a container, also for building images you can define a network. This means that your build containers will be connected to that network during the build.

		$ docker build --network my-custom-net .


	--no-cache
	-----------------

	We’ve briefly discussed this caching mechanism for the build option --cache-from . So you might have noticed by now that when you rebuild an image from the same Dockerfile without changing its instructions, Docker will make use of the previous builds’ cache to speed up your current build.
	What this option does is instruct Docker to not use its cache, even if the Dockerfile has remained the same.
		$ docker build --no-cache .


	--pull
	----------
	Your builds always have a parent image (unless you’re building from scratch but let’s not go there). Depending on the parent image you’re using, updates might happen upstream, and your local Docker daemon will not pull them because you already have that image tag on disk. For example, ubuntu:latest is updated oon Docker Hub everytime there is a new Ubuntu build, but locally, you might still have the ubuntu:latest image corresponding from a 6 months old release.

	With the --pull option you are telling Docker to always check for updates and pull the parent images you’re trying to use in you build.
	$ docker build --pull .


	--quiet
	-----------
	As the name says, build your image quietly, by preventing Docker from printing any output, beside the final image ID, to your terminal.

	$ docker build --quiet .

	This is useful for programmatic builds, to let your scripts save the resulting image ID directly into a variable.


	Specifying target build stage (--target)
	----------------------------------------
		$ docker image build -t mybuildimage --target build-env .				#Commands after the target stage will be skipped.

			FROM debian AS build-env
			...

			FROM alpine AS production-env

	Custom build outputs (--output or -o)   ENABLE BUILDKIT
	-------------------------------------------
		Allow you to export the build artifacts as files on the local filesystem instead of a Docker image, which can be useful for generating local binaries, code generation etc.

		$ docker build --output type=local,dest=out .				#local > exports the files to a directory named out
		$ docker build --output type=tar,dest=out.tar .				#tar The tar exporter is similar but writes the files as a single tarball (.tar).
		$ docker build -o - . > out.tar


		The --output option exports all files from the target stage. A common pattern for exporting only specific files is to do multi-stage builds and to copy the desired files to a new scratch stage with COPY --from

			FROM golang AS build-stage
			RUN go get -u github.com/LK4D4/vndr

			FROM scratch AS export-stage
			COPY --from=build-stage /go/bin/vndr /

			$ docker build -o out .


















sonar-scanner.bat -D"sonar.projectKey=venkat" -D"sonar.sources=." -D"sonar.host.url=http://localhost:9000" -D"sonar.login=ee649aede58293a1f3fe1801d77eef89a35403e4"

GitHUb

Git branching strategies
Mirror clone &
github vs git
cli >>>>
git stash
fetch & pull
remote branchin
what is cherrypicking

Jenkins ::
CICD >>
Master slave architecture
Master slave
	   windows
	   Linux
	   cloud
       docker
What type pipeline are
		GuI
		Declarative &
		Scripted
	Build queue
	Build executor
	what is multibranch pipeline vs normal pipleine
	Prehook & post hook & webhook

Sonarqube :: why we sonarqube ??
			what is static code analysis ??
			code covearge ??
			quality gate?  what is thresold value
			quality profile
jnekins with sonarwube



Nexus
=======
what is nexus ?? why do
Hosted repo & proxy repo
What are object we can store in nexus ?


Maven
=========

What is maven ??
lifecyle in maven
SNAPSHOT VERSION & RELEASE VERSION
git tag
Maven release
maven local repo vs maven central repo
mvn install vs mvn deploy
how to do  skip the test cases
What is mulite module projectKey

Docker
========

What is docker  ?? and its benifits & advange ? why developer prefer?
docker vs VM
what is docker image & what docker container
docker file
how to we create the image
FROM
entrypoint vs CMD
copy vs add
docker commmand >>> docker registries
how to docker images size
docker log
volume
docker secrets


Anisble
=========
Ansibles vs puppet
Anisbe architectre
wht is ansible roles ?
ansible adhoc command >>>
type of inventories ??
Playbook ??
playbook module >> 50
jinja template
what is handler
ansible vault ?



Teraform || kuberntes | could | linux commands


























